<!doctype html>
<html class="no-js" lang="">

<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Stylesheet Link -->

</head>

<body>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.18.1/dist/phaser.min.js"></script>
    <script>
        var enemyCount = 2;
        let kills = 0;
        var wave = 1;
        var life = 3;

        var Bullet = new Phaser.Class({
            Extends: Phaser.GameObjects.Image,
            initialize:
                // Bullet Constructor
                function Bullet(scene) {
                    Phaser.GameObjects.Image.call(this, scene, 0, 0, 'bullet');
                    this.speed = 0.5;
                    this.born = 0;
                    this.direction = 0;
                    this.xSpeed = 0;
                    this.ySpeed = 0;
                    this.setSize(12, 12, true);
                    this.setOrigin(0.5, 0.5);
                },

            // Fires a bullet from the player to the reticle
            fire: function (shooter, target) {
                this.setPosition(shooter.x, shooter.y); // Initial position
                this.direction = Math.atan((target.x - this.x) / (target.y - this.y));

                // Calculate X and y velocity of bullet to moves it from shooter to target
                if (target.y >= this.y) {
                    this.xSpeed = this.speed * Math.sin(this.direction);
                    this.ySpeed = this.speed * Math.cos(this.direction);
                } else {
                    this.xSpeed = -this.speed * Math.sin(this.direction);
                    this.ySpeed = -this.speed * Math.cos(this.direction);
                }

                this.rotation = shooter.rotation; // angle bullet with shooters rotation
                this.born = 0; // Time since new bullet spawned
            },

            // Updates the position of the bullet each cycle
            update: function (time, delta) {
                this.x += this.xSpeed * delta;
                this.y += this.ySpeed * delta;
                this.born += delta;
                if (this.born > 1800) {
                    this.setActive(false);
                    this.setVisible(false);
                }
            }
        });

        var SceneA = new Phaser.Class({

            Extends: Phaser.Scene,

            initialize:

                function SceneA() {
                    Phaser.Scene.call(this, {
                        key: 'sceneA',
                        extend: {
                            player: null,
                            enemies: null,
                            healthpoints: null,
                            reticle: null,
                            moveKeys: null,
                            playerBullets: null,
                            enemyBullets: null,
                            time: 0,
                            waveText: '',
                            killText: '',
                            lifeText: '',
                            timeEvent: 0
                        }
                    });
                },

            preload: function () {
                // Load in images and sprites
                this.load.spritesheet('player_handgun', 'assets/sprites/player_handgun.png', {
                    frameWidth: 66,
                    frameHeight: 60
                }); // Made by tokkatrain: https://tokkatrain.itch.io/top-down-basic-set
                this.load.image('bullet', 'assets/bullet.png');
                this.load.image('target', 'assets/red_crosshair.png');
                this.load.image('background', 'assets/skies/underwater1.png');
            },

            create: function () {
                // Set world bounds
                this.physics.world.setBounds(0, 0, 800, 600);
                const ourWorld = this.physics.world;

                // Add 2 groups for Bullet objects
                playerBullets = this.physics.add.group({
                    classType: Bullet,
                    runChildUpdate: true
                });

                enemyBullets = this.physics.add.group({
                    classType: Bullet,
                    runChildUpdate: true
                });

                // Add background player, enemy, reticle, healthpoint sprites
                var background = this.add.image(400, 300, 'background');
                player = this.physics.add.sprite(400, 300, 'player_handgun');

                enemies = this.physics.add.group({
                    collideWorldBounds: true,
                    setCollideWorldBounds: true,
                    onWorldBounds: true,
                });

                for (var i = 0; i < enemyCount; i++) {
                    const randomX = Math.floor((Math.random() * ourWorld.bounds.width) + 1);
                    const randomY = Math.floor((Math.random() * ourWorld.bounds.height) + 1);
                    enemies.create(randomX, randomY, 'player_handgun');
                }

                reticle = this.physics.add.sprite(800, 700, 'target');

                // Set image/sprite propertiessd
                background.setOrigin(0.5, 0.5).setDisplaySize(800, 600);
                player.setOrigin(0.5, 0.5).setDisplaySize(32, 32).setCollideWorldBounds(true).setDrag(800,
                    800);
                reticle.setOrigin(0.5, 0.5).setDisplaySize(25, 25).setCollideWorldBounds(true);
                enemies.getChildren().forEach(e => e.setOrigin(0.5, 0.5).setDisplaySize(100, 100)
                    .setCollideWorldBounds(true))

                player.body.immovable = true;

                // Set sprite variables
                player.health = 3;
                timedEvent = this.time.addEvent();
                enemies.getChildren().forEach(e => {
                    e.health = 1;
                    e.invincibleTimer = 0;
                });

                waveText = this.add.text(10, 10, '', {
                    font: '16px Arial',
                    fill: '#000000'
                });

                killsText = this.add.text(300, 10, '', {
                    font: '16px Arial',
                    fill: '#000000'
                });

                lifeText = this.add.text(700, 10, '', {
                    font: '16px Arial',
                    fill: '#000000'
                });

                // Set camera properties
                moveKeys = this.input.keyboard.addKeys({
                    'up': Phaser.Input.Keyboard.KeyCodes.W,
                    'down': Phaser.Input.Keyboard.KeyCodes.S,
                    'left': Phaser.Input.Keyboard.KeyCodes.A,
                    'right': Phaser.Input.Keyboard.KeyCodes.D
                });

                // Enables movement of player with WASD keys
                this.input.keyboard.on('keydown_W', function (event) {
                    player.setAccelerationY(-800);
                });
                this.input.keyboard.on('keydown_S', function (event) {
                    player.setAccelerationY(800);
                });
                this.input.keyboard.on('keydown_A', function (event) {
                    player.setAccelerationX(-800);
                });
                this.input.keyboard.on('keydown_D', function (event) {
                    player.setAccelerationX(800);
                });

                // Stops player acceleration on uppress of WASD keys
                this.input.keyboard.on('keyup_W', function (event) {
                    if (moveKeys['down'].isUp)
                        player.setAccelerationY(0);
                });
                this.input.keyboard.on('keyup_S', function (event) {
                    if (moveKeys['up'].isUp)
                        player.setAccelerationY(0);
                });
                this.input.keyboard.on('keyup_A', function (event) {
                    if (moveKeys['right'].isUp)
                        player.setAccelerationX(0);
                });
                this.input.keyboard.on('keyup_D', function (event) {
                    if (moveKeys['left'].isUp)
                        player.setAccelerationX(0);
                });

                // Fires bullet from player on left click of mouse
                this.input.on('pointerdown', function (pointer, time, lastFired) {
                    if (player.active === false) {
                        return;
                    } else {
                        var bullet = playerBullets.get().setActive(true).setVisible(true);

                        bullet.fire(player, reticle);
                        this.physics.add.collider(enemies.getChildren(), bullet, enemyHitCallback);
                    }
                }, this);

                // Move reticle 
                this.input.on('pointermove', function (pointer) {
                    reticle.x = pointer.position.x;
                    reticle.y = pointer.position.y;
                }, this);
            },

            update: function (time, delta) {
                // Rotates player to face towards reticle
                player.rotation = Phaser.Math.Angle.Between(player.x, player.y, reticle.x, reticle.y);

                enemies.getChildren().forEach(e => {
                    // Rotates enemy to face towards player
                    e.rotation = Phaser.Math.Angle.Between(e.x, e.y, player.x, player.y)

                    this.physics.add.collider(e, player, gotCaught, null, this);
                    this.physics.moveToObject(e, player)
                });

                this.physics.add.collider(enemies, enemies)

                if (enemies.getChildren().length === 0) {
                    enemyCount = Math.round(enemyCount * 1.5);
                    wave++;
                    this.scene.restart();
                }
                constrainVelocity(player, 500);

                // Display Texts
                waveText.setText(`Wave: ${wave}`);
                killsText.setText(`Kills: ${kills}`);
                lifeText.setText(`Life: ${life}`);
            }
        });

        // END OF SCENE

        function gotCaught(enemy, player) {
            if (this.time.now > enemy.invincibleTimer) {
                life--;
                enemy.invincibleTimer = this.time.now + 1000;
            }
        }

        function enemyHitCallback(enemyHit, bulletHit) {
            // Reduce health of enemy
            if (bulletHit.active === true && enemyHit.active === true) {
                enemyHit.health = enemyHit.health - 1;

                // Kill enemy if health <= 0
                if (enemyHit.health <= 0) {
                    kills++;
                    enemyHit.destroy();
                }

                // Destroy bullet
                bulletHit.setActive(false).setVisible(false);
            }
        }

        function enemyFire(enemy, player, time, gameObject) {
            if (enemy.active === false) {
                return;
            }

            if ((time - enemy.lastFired) > 1000) {
                enemy.lastFired = time;

                // Get bullet from bullets group
                var bullet = enemyBullets.get().setActive(true).setVisible(true);

                if (bullet) {
                    bullet.fire(enemy, player);
                    // Add collider between bullet and player
                    gameObject.physics.add.collider(player, bullet, playerHitCallback);
                }
            }
        }

        // Ensures sprite speed doesnt exceed maxVelocity while update is called
        function constrainVelocity(sprite, maxVelocity) {
            if (!sprite || !sprite.body)
                return;

            var angle, currVelocitySqr, vx, vy;
            vx = sprite.body.velocity.x;
            vy = sprite.body.velocity.y;
            currVelocitySqr = vx * vx + vy * vy;

            if (currVelocitySqr > maxVelocity * maxVelocity) {
                angle = Math.atan2(vy, vx);
                vx = Math.cos(angle) * maxVelocity;
                vy = Math.sin(angle) * maxVelocity;
                sprite.body.velocity.x = vx;
                sprite.body.velocity.y = vy;
            }
        }

        // Ensures reticle does not move offscreen
        function constrainReticle(reticle) {
            var distX = reticle.x - player.x; // X distance between player & reticle
            var distY = reticle.y - player.y; // Y distance between player & reticle

            // Ensures reticle cannot be moved offscreen (player follow)
            if (distX > 800)
                reticle.x = player.x + 0;
            else if (distX < -800)
                reticle.x = player.x - 0;

            if (distY > 600)
                reticle.y = player.y + 0;
            else if (distY < -600)
                reticle.y = player.y - 0;
        }

        var config = {
            type: Phaser.AUTO,
            parent: 'phaser-example',
            width: 800,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: {
                        y: 0
                    },
                    debug: true
                }
            },
            scene: [SceneA],
        };

        var game = new Phaser.Game(config);
    </script>
</body>

</html>